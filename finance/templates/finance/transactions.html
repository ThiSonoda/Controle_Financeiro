{% extends "finance/base.html" %}
{% load static %}

{% block content %}
<!-- Cabeçalho com título e navs -->
<div style="margin-bottom: 20px;">
  <h1 style="margin-top: 0; margin-bottom: 12px;">Lançamentos (Receitas / Despesas)</h1>
  
  <!-- Card selector nav (Débito + Credit Cards) -->
  <div id="card_selector" style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
    <button type="button" class="card-btn" data-card-id="" data-card-name="" data-owner-tag="">Débito</button>
    {% for card in credit_cards %}
      {% if 'bradesco' in card.name.lower %}
        <!-- Separar Bradesco em dois navs: Bradesco Thi e Bradesco Tha -->
        <button type="button" class="card-btn" data-card-id="{{ card.id }}" data-card-name="{{ card.name }}" data-owner-tag="Thi">Bradesco Thi</button>
        <button type="button" class="card-btn" data-card-id="{{ card.id }}" data-card-name="{{ card.name }}" data-owner-tag="Tha">Bradesco Tha</button>
      {% else %}
        <button type="button" class="card-btn" data-card-id="{{ card.id }}" data-card-name="{{ card.name }}" data-owner-tag="">{{ card.name }}</button>
      {% endif %}
    {% endfor %}
  </div>
</div>

<!-- {% if messages %}
  <ul class="messages">
    {% for message in messages %}
      <li class="{{ message.tags }}">{{ message }}</li>
    {% endfor %}
  </ul>
{% endif %} -->

<h2>Novo lançamento</h2>

<style>
  .transactions-layout { display: flex; gap: 24px; align-items: flex-start; }
  .transactions-layout .left-column { flex: 1 1 0; min-width: 320px; }
  .transactions-layout .middle-column { width: 80px; flex-shrink: 0; align-self: stretch; }
  .transactions-layout .right-column { width: 360px; max-width: 42%; }
  
  /* Seção de informações da subcategoria (gráfico) */
  #subcategory_info_section {
    width: 100%;
    height: 100%;
    display: none;
    flex-direction: column;
  }
  
  
  #subcategory_chart_label {
    font-size: 12px;
    font-weight: 600;
    color: #333;
    margin-bottom: 8px;
    text-align: center;
    word-wrap: break-word;
    line-height: 1.3;
  }
  
  #subcategory_chart_container {
    flex: 1;
    min-height: 0;
    display: flex;
    align-items: stretch;
    justify-content: center;
    position: relative;
  }
  
  #subcategoryChart {
    width: 100% !important;
    height: 100% !important;
  }
  
  @media (max-width: 1200px) {
    .transactions-layout .middle-column {
      display: none;
    }
  }

  /* Tooltip para comentário */
  .comment-icon {
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
  
  .comment-icon:hover {
    border-color: #666 !important;
    color: #666 !important;
  }
  
  .comment-tooltip {
    visibility: hidden;
    opacity: 0;
    background-color: #333;
    color: #fff;
    text-align: left;
    border-radius: 6px;
    padding: 10px 12px;
    position: absolute;
    z-index: 1000;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    white-space: pre-wrap;
    word-wrap: break-word;
    max-width: 300px;
    font-size: 13px;
    line-height: 1.4;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    transition: opacity 0.3s, visibility 0.3s;
    pointer-events: none;
  }
  
  .comment-tooltip::after {
    content: "";
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border-width: 6px;
    border-style: solid;
    border-color: #333 transparent transparent transparent;
  }
  
  .comment-icon:hover .comment-tooltip {
    visibility: visible;
    opacity: 1;
  }

  /* Form controls full width and spacing */
  .transactions-layout form div { margin-bottom: 12px; }
  .transactions-layout label { display: block; margin-bottom: 6px; font-weight: 600; }
  .transactions-layout input[type="text"],
  .transactions-layout input[type="date"],
  .transactions-layout input[type="number"],
  .transactions-layout input[type="month"],
  .transactions-layout select,
  .transactions-layout textarea {
    width: 100%;
    box-sizing: border-box;
    padding: 8px 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 16px;
  }
   /* Altura específica para o campo de subcategoria (removido - agora é input de busca) */
    /* Altura específica para o campo de Tipo */
    #id_type {
    height: 40px;
  }

  .transactions-layout button { padding: 8px 14px; border-radius: 4px; }

  /* Card selector buttons */
  .card-btn {
    background: #fff;
    border: 1px solid #ddd;
    padding: 6px 10px;
    border-radius: 6px;
    cursor: pointer;
    color: #222; /* ensure readable text color when not selected */
  }
  .card-btn:hover { background: #f5f7fa; color: #111; }
  .card-btn.active { background: #1976d2; color: #fff; border-color: #1976d2; font-weight: 700; }

  /* Right column visual tweaks */
  .transactions-layout .right-column { background: #fafafa; padding: 12px; border-radius: 6px; border: 1px solid #eee; }
  .transactions-layout .right-column table { width: 100%; border-collapse: collapse; }
  .transactions-layout .right-column th,
  .transactions-layout .right-column td { border: 1px solid #e6e6e6; padding: 8px; }

  @media (max-width: 900px) {
    .transactions-layout { flex-direction: column; }
    .transactions-layout .right-column { width: 100%; max-width: none; }
  }

</style>

<div class="transactions-layout">
  <div class="left-column">
<form method="post" action="">
  {% csrf_token %}
      <div style="display: flex; gap: 16px;">
        <div style="flex: 1;">
    <label for="id_date">Data:</label>
          <input type="date" id="id_date" name="date" required value="{{ default_date }}">
  </div>

        <div style="flex: 1;">
    <label for="id_type">Tipo:</label>
    <select id="id_type" name="type" required>
            <option value="EX">Despesa</option>
      <option value="IN">Receita</option>
    </select>
        </div>
  </div>

      <div style="display: flex; gap: 16px;">
        <div style="flex: 1;">
    <label for="id_amount">Valor:</label>
    <input type="number" id="id_amount" name="amount" step="0.01" min="0" required>
  </div>

        <div style="flex: 1; position: relative;">
          <label for="id_subcategory_search">Subcategoria:</label>
          <input type="text" 
                 id="id_subcategory_search" 
                 autocomplete="off"
                 placeholder="Digite para buscar..."
                 style="width: 100%; box-sizing: border-box; padding: 8px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px;">
          <input type="hidden" id="id_subcategory" name="subcategory" required>
          <div id="subcategory_dropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ccc; border-top: none; border-radius: 0 0 4px 4px; max-height: 300px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
          </div>
        </div>
  </div>

      <!-- <div>
    <label for="id_account">Conta:</label>
    <select id="id_account" name="account" required>
      <option value="">-- selecione --</option>
      {% for a in accounts %}
        <option value="{{ a.id }}">{{ a.name }}</option>
      {% endfor %}
    </select>
      </div> -->

      <!-- credit_card select removed: selection is done via the card selector nav above -->

  <div>
    <label for="id_description">Descrição:</label>
    <input type="text" id="id_description" name="description">
  </div>

      <div>
        <label for="id_comment">Comentário (opcional):</label>
        <textarea id="id_comment" name="comment" rows="3" placeholder="Adicione um comentário sobre este lançamento..."></textarea>
      </div>

      <!-- Campo owner_tag agora é hidden e preenchido automaticamente pelo JavaScript -->
      <input type="hidden" id="id_owner_tag" name="owner_tag" value="">

      <fieldset id="installment_fieldset" style="margin-top: 15px; padding: 10px; border: 1px solid #ccc; border-radius: 6px; display: none;">
    <legend>Compra parcelada no cartão</legend>

    <div>
      <label>
        <input type="checkbox" name="is_installment" id="id_is_installment" onchange="toggleInstallmentFields()">
        Lançar como compra parcelada?
      </label>
    </div>

    <div id="installment_fields" style="margin-top: 8px; display: none;">
          <div style="margin-bottom: 10px;">
        <label for="id_installments">Número de parcelas:</label>
        <input type="number" id="id_installments" name="installments" min="2" value="2">
      </div>
          <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">O valor informado é:</label>
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
              <input type="radio" name="amount_type" value="total" checked>
              <span>Valor Total da Compra</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px;">
              <input type="radio" name="amount_type" value="installment">
              <span>Valor de Cada Parcela</span>
            </label>
      </div>
      <small>
        O sistema irá criar uma transação por parcela, em meses consecutivos.
      </small>
    </div>
  </fieldset>

  <div style="margin-top: 12px;">
    <button type="submit" style="padding: 14px 32px; font-size: 18px; font-weight: 600; background-color: #1976d2; color: white; border: none; border-radius: 6px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: background-color 0.2s;">Salvar</button>
  </div>

</form>

  </div>

  <!-- Coluna do Meio: Gráfico de Barra Simplificado -->
  <aside class="middle-column">
    <div id="subcategory_info_section" style="display: none;">
      <div id="subcategory_chart_label"></div>
      <div id="subcategory_chart_container">
        <canvas id="subcategoryChart" style="max-width: 100%; max-height: 100%;"></canvas>
      </div>
    </div>
  </aside>

  <aside class="right-column">
    <!-- Filtro de Período -->
    <div style="background-color: #f5f5f5; padding: 15px; border-radius: 6px; margin-bottom: 20px; border: 1px solid #ddd;">
      <div style="display: flex; gap: 15px; align-items: flex-end;">
        <div>
          <label for="invoice_year" style="display: block; font-weight: 600; margin-bottom: 5px;">Ano:</label>
          <input type="number" id="invoice_year" name="invoice_year" 
                 value="{{ selected_year }}" 
                 min="2020" 
                 max="2100"
                 style="width: 80px; padding: 6px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px;">
        </div>
        <div>
          <label for="invoice_month" style="display: block; font-weight: 600; margin-bottom: 5px;">Mês:</label>
          <select id="invoice_month" name="invoice_month" style="padding: 6px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; height: 30px">
            <option value="1" {% if selected_month == 1 %}selected{% endif %}>Janeiro</option>
            <option value="2" {% if selected_month == 2 %}selected{% endif %}>Fevereiro</option>
            <option value="3" {% if selected_month == 3 %}selected{% endif %}>Março</option>
            <option value="4" {% if selected_month == 4 %}selected{% endif %}>Abril</option>
            <option value="5" {% if selected_month == 5 %}selected{% endif %}>Maio</option>
            <option value="6" {% if selected_month == 6 %}selected{% endif %}>Junho</option>
            <option value="7" {% if selected_month == 7 %}selected{% endif %}>Julho</option>
            <option value="8" {% if selected_month == 8 %}selected{% endif %}>Agosto</option>
            <option value="9" {% if selected_month == 9 %}selected{% endif %}>Setembro</option>
            <option value="10" {% if selected_month == 10 %}selected{% endif %}>Outubro</option>
            <option value="11" {% if selected_month == 11 %}selected{% endif %}>Novembro</option>
            <option value="12" {% if selected_month == 12 %}selected{% endif %}>Dezembro</option>
          </select>
        </div>
        <div>
          <button type="button" onclick="updateInvoiceMonth()" style="padding: 6px 12px; font-size: 14px;">Atualizar</button>
        </div>
      </div>
    </div>

    <script>
      function updateInvoiceMonth() {
        const yearInput = document.getElementById('invoice_year');
        const monthInput = document.getElementById('invoice_month');
        const year = yearInput.value;
        const month = monthInput.value;
        
        if (year && month) {
          // Validar valores
          const yearNum = parseInt(year);
          const monthNum = parseInt(month);
          
          if (yearNum >= 2020 && yearNum <= 2100 && monthNum >= 1 && monthNum <= 12) {
            window.location.href = '{% url "finance:transactions" %}?year=' + year + '&month=' + month;
          } else {
            alert('Por favor, insira um ano entre 2020 e 2100.');
          }
        } else {
          alert('Por favor, preencha o ano e selecione o mês.');
        }
      }
      
      // Permitir atualizar ao pressionar Enter no campo de ano ou ao mudar o mês
      document.getElementById('invoice_year').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          updateInvoiceMonth();
        }
      });
      
      document.getElementById('invoice_month').addEventListener('change', function() {
        updateInvoiceMonth();
      });
    </script>

    <h2 style="margin-top: 0;">Saldo das Contas</h2>

    <section style="margin-bottom: 16px;">
      {% if accounts %}
        <ul style="list-style: none; padding: 0; margin: 0 0 8px 0;">
          {% for a in accounts %}
            <li style="display:flex; justify-content:space-between; padding:6px 8px; border-radius:4px; background:#fff; margin-bottom:6px; align-items:center;">
              <span style="font-weight:600;">{{ a.name }}</span>
              <span style="font-family: monospace; font-size: 16px;">R$ {{ a.balance|floatformat:2 }}</span>
            </li>
          {% endfor %}
        </ul>
      {% else %}
        <p style="color:#666; margin:0 0 8px 0;">Nenhuma conta cadastrada.</p>
      {% endif %}
    </section>

    <h2 style="margin-top: 0;">Faturas dos Cartões de Crédito</h2>

    {% if credit_card_invoices %}
      <table border="1" cellspacing="0" cellpadding="8" style="width: 100%; margin-bottom: 20px;">
        <thead>
          <tr>
            <th style="text-align: center;">Cartão</th>
            <th style="text-align: center; min-width: 100px;">Total</th>
            <th style="text-align: center;">Status</th>
            <th style="text-align: center;">Ações</th>
          </tr>
        </thead>
        <tbody>
          {% for invoice in credit_card_invoices %}
            {% if invoice.count > 0 %}
              <tr>
                <td>{{ invoice.card.name }}</td>
                <td style="text-align: right; font-weight: bold; min-width: 100px;">
                  R$ {{ invoice.total|floatformat:2 }}
                </td>
                <td style="text-align: center;">
                  {% if invoice.is_paid %}
                    <span style="color: #4caf50; font-weight: bold;">✓ Paga</span>
                  {% else %}
                    <span style="color: #ff9800; font-weight: bold;">Pendente</span>
                  {% endif %}
                </td>
                <td style="text-align: center;">
                  {% if invoice.is_paid %}
                    <a href="{% url 'finance:reopen_invoice' invoice.card.id selected_year selected_month %}" 
                       style="color: #ff9800; margin-right: 10px;">Reabrir Fatura</a>
                  {% else %}
                    <a href="{% url 'finance:pay_invoice' invoice.card.id selected_year selected_month %}" 
                       style="color: #4caf50; font-weight: bold;">Pagar Fatura</a>
                  {% endif %}
                </td>
              </tr>
            {% endif %}
          {% endfor %}
        </tbody>
      </table>
      
      {% if has_invoices %}
        <div style="margin-top: 15px;">
          <a href="{% url 'finance:credit_card_refunds' %}" 
             style="padding: 6px 12px; background-color: #9e9e9e; color: white; text-decoration: none; border-radius: 4px; display: inline-block; font-size: 14px;">
            Estornos
          </a>
        </div>
      {% endif %}
    {% else %}
      <p style="color: #666;">Nenhum cartão cadastrado ou nenhuma fatura no período selecionado.</p>
    {% endif %}
  </aside>

</div>

<h2>Últimos lançamentos - {{ selected_month|stringformat:"02d" }}/{{ selected_year }}</h2>

<div style="margin-bottom: 15px;">
  <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
    <input type="checkbox" 
           id="show_previous_month" 
           {% if show_previous_month %}checked{% endif %}
           onchange="togglePreviousMonth()"
           style="width: auto; margin: 0;">
    <span>Mostrar mês anterior</span>
  </label>
  <script>
    function togglePreviousMonth() {
      const checkbox = document.getElementById('show_previous_month');
      const url = new URL(window.location.href);
      if (checkbox.checked) {
        url.searchParams.set('previous_month', '1');
      } else {
        url.searchParams.delete('previous_month');
      }
      window.location.href = url.toString();
    }
    
    // Função applyOwnerTagFilter removida - a tag agora é definida automaticamente pelo nav selecionado
  </script>
</div>

{% if transactions %}
  <table border="1" cellspacing="0" cellpadding="4">
    <thead>
      <tr>
        <th>Data Lançamento</th>
        <th>Data Pagamento</th>
        <th>Tipo</th>
        <th style="min-width: 100px;">Valor</th>
        <th>Categoria</th>
        <th>Cartão</th>
        {% if is_bradesco_selected %}
        <th>Tag</th>
        {% endif %}
        <th>Descrição</th>
        <th>Ações</th>
      </tr>
    </thead>
    <tbody>
      {% for t in transactions %}
        <tr>
          <td>{{ t.date|date:"d/m/Y" }}</td>
          <td>
            {% if t.payment_date %}
              {{ t.payment_date|date:"d/m/Y" }}
              {% if t.date != t.payment_date %}
                <small style="color: #666; display: block;">(vencimento)</small>
              {% endif %}
            {% else %}
              {{ t.date|date:"d/m/Y" }}
            {% endif %}
          </td>
          <td>
            {% if t.type == "IN" %}
              Receita
            {% else %}
              Despesa
            {% endif %}
          </td>
          <td style="min-width: 100px;">
            {% if t.type == "EX" %}-{% endif %}
            R$ {{ t.amount }}
          </td>
          <td style="text-align: center;">
            {% if t.subcategory %}
              {{ t.subcategory.category.name }} - {{ t.subcategory.name }}
            {% else %}
              {{ t.category.name|default:"-" }}
            {% endif %}
          </td>

          <td>{{ t.credit_card.name|default:"-" }}</td>
          {% if is_bradesco_selected %}
          <td>
            {% if t.owner_tag %}
              {% if t.owner_tag == "Thi" %}
                Thiago (Thi)
              {% elif t.owner_tag == "Tha" %}
                Thaís (Tha)
              {% else %}
                {{ t.owner_tag }}
              {% endif %}
            {% else %}
              -
            {% endif %}
          </td>
          {% endif %}
          <td>
            {{ t.description|default:"-" }}
            {% if t.comment and t.comment|length > 0 %}
              <span class="comment-icon" style="cursor: pointer; margin-left: 5px; vertical-align: middle; display: inline-flex; align-items: center; justify-content: center; width: 12px; height: 12px; border-radius: 50%; border: 1px solid #999; color: #999; font-size: 8px; font-weight: bold; font-style: italic; font-family: serif; line-height: 1;">
                i
                <span class="comment-tooltip">{{ t.comment }}</span>
              </span>
            {% endif %}
          </td>
          <td>
            <a href="{% url 'finance:edit_transaction' t.id %}?next=transactions" style="margin-right: 8px;">Editar</a>
            <form method="post" action="{% url 'finance:delete_transaction' t.id %}" style="display: inline;" onsubmit="return confirm('Tem certeza que deseja deletar este lançamento?');">
              {% csrf_token %}
              <button type="submit" class="logout-link" style="color: #c62828; padding: 0; margin: 0;">Deletar</button>
            </form>
          </td>
        </tr>
      {% endfor %}
    </tbody>
    <tfoot>
      <tr>
        <td colspan="3" style="font-weight: bold; text-align: right;">Total</td>
        <td style="font-weight: bold; min-width: 100px;">
          R$ {{ total_signed_amount|floatformat:2 }}
        </td>
        <td colspan="{% if is_bradesco_selected %}4{% else %}3{% endif %}"></td>
        <td></td>
      </tr>
    </tfoot>
  </table>
{% else %}
  <p>Nenhum lançamento encontrado.</p>
{% endif %}

<script>
  function toggleInstallmentFields() {
    const chk = document.getElementById('id_is_installment');
    const box = document.getElementById('installment_fields');
    box.style.display = chk.checked ? 'block' : 'none';
  }
</script>

<script>
  // Autocomplete para Subcategoria
  (function() {
    // Dados das subcategorias
    const subcategories = [
      {% for subcat in subcategories %}
      {
        id: {{ subcat.id }},
        name: "{{ subcat.name|escapejs }}",
        category: "{{ subcat.category.name|escapejs }}",
        isIncome: {{ subcat.category.is_income|yesno:"true,false" }},
        displayText: "{{ subcat.name|escapejs }} - {{ subcat.category.name|escapejs }}{% if subcat.category.is_income %} (receita){% endif %}"
      }{% if not forloop.last %},{% endif %}
      {% endfor %}
    ];

    const searchInput = document.getElementById('id_subcategory_search');
    const hiddenInput = document.getElementById('id_subcategory');
    const dropdown = document.getElementById('subcategory_dropdown');
    const typeSelect = document.getElementById('id_type');
    let selectedIndex = -1;
    let filteredSubcategories = [];

    function getAvailableSubcategories() {
      // Filtrar por tipo de transação se selecionado
      if (typeSelect && typeSelect.value) {
        const isIncome = typeSelect.value === 'IN';
        return subcategories.filter(subcat => subcat.isIncome === isIncome);
      }
      return subcategories;
    }

    function filterSubcategories(query) {
      const available = getAvailableSubcategories();
      
      if (!query || query.trim() === '') {
        return available;
      }
      const lowerQuery = query.toLowerCase();
      return available.filter(subcat => 
        subcat.name.toLowerCase().includes(lowerQuery) ||
        subcat.category.toLowerCase().includes(lowerQuery) ||
        subcat.displayText.toLowerCase().includes(lowerQuery)
      );
    }

    function renderDropdown(subcategories) {
      filteredSubcategories = subcategories;
      selectedIndex = -1;
      
      if (subcategories.length === 0) {
        dropdown.innerHTML = '<div style="padding: 10px; color: #666;">Nenhuma subcategoria encontrada</div>';
        dropdown.style.display = 'block';
        return;
      }

      dropdown.innerHTML = subcategories.map((subcat, index) => 
        `<div class="subcategory-option" data-index="${index}" data-id="${subcat.id}" style="padding: 8px 10px; cursor: pointer; border-bottom: 1px solid #eee;" onmouseover="this.style.backgroundColor='#f5f5f5'" onmouseout="this.style.backgroundColor='white'">
          <strong>${subcat.name}</strong> - ${subcat.category}${subcat.isIncome ? ' <span style="color: #2e7d32;">(receita)</span>' : ''}
        </div>`
      ).join('');

      // Adicionar event listeners
      dropdown.querySelectorAll('.subcategory-option').forEach(option => {
        option.addEventListener('click', function() {
          const index = parseInt(this.getAttribute('data-index'));
          selectSubcategory(filteredSubcategories[index]);
        });
      });

      dropdown.style.display = 'block';
    }

    function selectSubcategory(subcat) {
      hiddenInput.value = subcat.id;
      searchInput.value = subcat.displayText;
      dropdown.style.display = 'none';
      selectedIndex = -1;
      
      // Validar o campo hidden
      hiddenInput.setCustomValidity('');
      
      // Atualizar informações da subcategoria
      if (typeof updateSubcategoryInfo === 'function') {
        updateSubcategoryInfo();
      }
    }

    function highlightOption(index) {
      const options = dropdown.querySelectorAll('.subcategory-option');
      options.forEach((opt, i) => {
        if (i === index) {
          opt.style.backgroundColor = '#e3f2fd';
          opt.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        } else {
          opt.style.backgroundColor = 'white';
        }
      });
    }

    // Event listeners
    searchInput.addEventListener('input', function() {
      const query = this.value;
      const filtered = filterSubcategories(query);
      renderDropdown(filtered);
      
      // Se o texto não corresponde a nenhuma subcategoria selecionada, limpar o hidden
      if (hiddenInput.value) {
        const selected = subcategories.find(s => s.id == hiddenInput.value);
        if (!selected || selected.displayText !== query) {
          hiddenInput.value = '';
          searchInput.setCustomValidity('Por favor, selecione uma subcategoria válida');
        } else {
          searchInput.setCustomValidity('');
        }
      }
    });

    searchInput.addEventListener('focus', function() {
      if (this.value) {
        const filtered = filterSubcategories(this.value);
        renderDropdown(filtered);
      } else {
        const available = getAvailableSubcategories();
        renderDropdown(available);
      }
    });

    // Limpar seleção quando o tipo de transação mudar
    if (typeSelect) {
      typeSelect.addEventListener('change', function() {
        // Limpar seleção de subcategoria quando mudar o tipo
        hiddenInput.value = '';
        searchInput.value = '';
        dropdown.style.display = 'none';
      });
    }

    searchInput.addEventListener('keydown', function(e) {
      if (!dropdown.style.display || dropdown.style.display === 'none') {
        return;
      }

      const options = dropdown.querySelectorAll('.subcategory-option');
      
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectedIndex = Math.min(selectedIndex + 1, options.length - 1);
        highlightOption(selectedIndex);
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectedIndex = Math.max(selectedIndex - 1, -1);
        if (selectedIndex >= 0) {
          highlightOption(selectedIndex);
        } else {
          options.forEach(opt => opt.style.backgroundColor = 'white');
        }
      } else if (e.key === 'Enter') {
        e.preventDefault();
        if (selectedIndex >= 0 && filteredSubcategories[selectedIndex]) {
          selectSubcategory(filteredSubcategories[selectedIndex]);
        } else if (filteredSubcategories.length === 1) {
          selectSubcategory(filteredSubcategories[0]);
        }
      } else if (e.key === 'Escape') {
        dropdown.style.display = 'none';
        selectedIndex = -1;
      }
    });

    // Fechar dropdown ao clicar fora
    document.addEventListener('click', function(e) {
      if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
        dropdown.style.display = 'none';
      }
    });

    // Validação do formulário
    const form = searchInput.closest('form');
    if (form) {
      form.addEventListener('submit', function(e) {
        if (!hiddenInput.value) {
          e.preventDefault();
          searchInput.setCustomValidity('Por favor, selecione uma subcategoria');
          searchInput.reportValidity();
          return false;
        }
        searchInput.setCustomValidity('');
      });
    }
  })();
</script>

<script>
  // Variável global para armazenar a instância do gráfico
  let subcategoryChartInstance = null;

  // Dados dos cartões de crédito (passados do backend)
  const creditCardsData = {
    {% for card in credit_cards %}
    {{ card.id }}: {
      id: {{ card.id }},
      name: "{{ card.name|escapejs }}",
      closing_day: {{ card.closing_day }},
      due_day: {{ card.due_day }}
    }{% if not forloop.last %},{% endif %}
    {% endfor %}
  };

  // Função para calcular a data de vencimento da fatura (equivalente à função Python)
  function calculateInvoiceDueDate(transactionDate, closingDay, dueDay) {
    const year = transactionDate.getFullYear();
    const month = transactionDate.getMonth() + 1; // JavaScript months are 0-indexed
    const day = transactionDate.getDate();
    
    // Passo 1: Identificar o mês em que a fatura fecha
    let closingMonth, closingYear;
    if (day <= closingDay) {
      // Fatura fecha no mês atual
      closingMonth = month;
      closingYear = year;
    } else {
      // Fatura fecha no próximo mês
      closingMonth = month + 1;
      closingYear = year;
      if (closingMonth > 12) {
        closingMonth = 1;
        closingYear = year + 1;
      }
    }
    
    // Passo 2: Calcular a data de vencimento
    let dueMonth, dueYear;
    if (dueDay >= closingDay) {
      // Vencimento está no mesmo mês que o fechamento
      dueMonth = closingMonth;
      dueYear = closingYear;
    } else {
      // Vencimento está no próximo mês após o fechamento
      dueMonth = closingMonth + 1;
      dueYear = closingYear;
      if (dueMonth > 12) {
        dueMonth = 1;
        dueYear = closingYear + 1;
      }
    }
    
    // Ajusta o dia de vencimento para o último dia do mês se necessário
    const daysInMonth = new Date(dueYear, dueMonth, 0).getDate();
    const finalDueDay = Math.min(dueDay, daysInMonth);
    
    return new Date(dueYear, dueMonth - 1, finalDueDay); // JavaScript months are 0-indexed
  }

  // Função para obter o cartão selecionado
  function getSelectedCard() {
    const activeButton = document.querySelector('.card-btn.active');
    if (!activeButton) return null;
    
    const cardId = activeButton.getAttribute('data-card-id');
    if (!cardId || cardId.trim() === '') return null; // Débito
    
    return creditCardsData[cardId] || null;
  }

  // Função para buscar e exibir informações da subcategoria
  function updateSubcategoryInfo() {
    const dateInput = document.getElementById('id_date');
    const amountInput = document.getElementById('id_amount');
    const subcategoryInput = document.getElementById('id_subcategory');
    const yearInput = document.getElementById('invoice_year');
    const monthInput = document.getElementById('invoice_month');
    const infoSection = document.getElementById('subcategory_info_section');
    const chartCanvas = document.getElementById('subcategoryChart');
    
    // Verificar se campos obrigatórios estão preenchidos (data, valor e subcategoria)
    if (!dateInput || !dateInput.value || !amountInput || !amountInput.value || !subcategoryInput || !subcategoryInput.value) {
      infoSection.style.display = 'none';
      if (subcategoryChartInstance) {
        subcategoryChartInstance.destroy();
        subcategoryChartInstance = null;
      }
      return;
    }
    
    // Extrair ano e mês - considerar método de pagamento
    let year, month;
    if (dateInput.value) {
      const dateParts = dateInput.value.split('-');
      const transactionDate = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]));
      
      // Verificar se é cartão de crédito
      const selectedCard = getSelectedCard();
      if (selectedCard) {
        // Para cartão de crédito, calcular o mês de vencimento da fatura
        const dueDate = calculateInvoiceDueDate(transactionDate, selectedCard.closing_day, selectedCard.due_day);
        year = dueDate.getFullYear();
        month = dueDate.getMonth() + 1; // JavaScript months are 0-indexed
      } else {
        // Para débito, usar o mês da data de lançamento
        year = parseInt(dateParts[0]);
        month = parseInt(dateParts[1]);
      }
    } else if (yearInput && yearInput.value && monthInput && monthInput.value) {
      // Fallback: usar campos de filtro se a data não estiver preenchida
      year = parseInt(yearInput.value);
      month = parseInt(monthInput.value);
    } else {
      infoSection.style.display = 'none';
      if (subcategoryChartInstance) {
        subcategoryChartInstance.destroy();
        subcategoryChartInstance = null;
      }
      return;
    }
    
    const subcategoryId = subcategoryInput.value;
    
    // Fazer requisição AJAX
    fetch(`{% url 'finance:subcategory_budget_info' %}?subcategory_id=${subcategoryId}&year=${year}&month=${month}`)
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // Calcular valores e porcentagens
          const budget = data.budget || 0;
          const spent = Math.abs(data.spent);
          
          // Obter valor do campo de valor (sempre usar valor absoluto para o gráfico)
          const amountValue = Math.abs(parseFloat(amountInput.value) || 0);
          
          // Calcular novo gasto (gasto atual + valor do lançamento)
          const newSpentTotal = spent + amountValue;
          const newPercentage = budget > 0 ? (newSpentTotal / budget) * 100 : 0;
          
          // Cores para a barra do gasto atual (barra inferior)
          let spentBarColor, spentBarBorderColor;
          const spentPercentage = budget > 0 ? (spent / budget) * 100 : 0;
          if (budget === 0 && spent > 0) {
            spentBarColor = 'rgba(198, 40, 40, 0.7)';
            spentBarBorderColor = 'rgba(198, 40, 40, 1)';
          } else if (spentPercentage < 85) {
            spentBarColor = 'rgba(33, 150, 243, 0.7)';
            spentBarBorderColor = 'rgba(33, 150, 243, 1)';
          } else if (spentPercentage <= 100) {
            spentBarColor = 'rgba(255, 152, 0, 0.7)';
            spentBarBorderColor = 'rgba(255, 152, 0, 1)';
          } else {
            spentBarColor = 'rgba(198, 40, 40, 0.7)';
            spentBarBorderColor = 'rgba(198, 40, 40, 1)';
          }
          
          // Cores para a barra do novo valor (barra superior empilhada)
          // Usar uma versão mais clara/transparente para diferenciar
          let newValueBarColor, newValueBarBorderColor;
          if (budget === 0 && newSpentTotal > 0) {
            newValueBarColor = 'rgba(198, 40, 40, 0.5)';
            newValueBarBorderColor = 'rgba(198, 40, 40, 0.8)';
          } else if (newPercentage < 85) {
            newValueBarColor = 'rgba(33, 150, 243, 0.5)';
            newValueBarBorderColor = 'rgba(33, 150, 243, 0.8)';
          } else if (newPercentage <= 100) {
            newValueBarColor = 'rgba(255, 152, 0, 0.5)';
            newValueBarBorderColor = 'rgba(255, 152, 0, 0.8)';
          } else {
            newValueBarColor = 'rgba(198, 40, 40, 0.5)';
            newValueBarBorderColor = 'rgba(198, 40, 40, 0.8)';
          }
          
          // Criar ou atualizar o gráfico
          if (typeof Chart !== 'undefined' && chartCanvas) {
            const ctx = chartCanvas.getContext('2d');
            
            // Destruir gráfico existente se houver
            if (subcategoryChartInstance) {
              subcategoryChartInstance.destroy();
            }
            
            // Plugin para desenhar linha de referência e porcentagem
            const customPlugin = {
              id: 'customElements',
              afterDatasetsDraw: function(chart) {
                const ctx = chart.ctx;
                const meta0 = chart.getDatasetMeta(0); // Barra do gasto atual
                const meta1 = chart.getDatasetMeta(1); // Barra do novo valor
                const yScale = chart.scales.y;
                const currentBudget = budget;
                const currentNewSpentTotal = newSpentTotal;
                const currentNewPercentage = newPercentage;
                const currentNewValueBarBorderColor = newValueBarBorderColor;
                
                ctx.save();
                
                // Desenhar linha de referência para orçado
                if (currentBudget > 0) {
                  const budgetY = yScale.getPixelForValue(currentBudget);
                  const bar = meta0.data[0];
                  const barLeft = bar.x - bar.width / 2;
                  const barRight = bar.x + bar.width / 2;
                  
                  // Linha mais destacada - cor mais vibrante e espessura maior
                  ctx.strokeStyle = 'rgba(46, 125, 50, 1)'; // Opacidade total
                  ctx.lineWidth = 4; // Espessura maior
                  ctx.setLineDash([5, 3]); // Traços mais longos e espaçados
                  ctx.beginPath();
                  ctx.moveTo(barLeft, budgetY);
                  ctx.lineTo(barRight, budgetY);
                  ctx.stroke();
                  ctx.setLineDash([]);
                }
                
                // Adicionar porcentagem no topo da barra empilhada (baseado no novo gasto total)
                if (currentNewSpentTotal > 0 && meta1.data[0]) {
                  const bar = meta1.data[0];
                  const x = bar.x;
                  const y = bar.y;
                  let text;
                  
                  if (currentBudget === 0) {
                    text = 'N/A';
                  } else {
                    text = currentNewPercentage.toFixed(1) + '%';
                  }
                  
                  ctx.font = 'bold 11px Arial';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'bottom';
                  ctx.fillStyle = currentNewValueBarBorderColor;
                  ctx.fillText(text, x, y - 5);
                }
                
                ctx.restore();
              }
            };
            
            subcategoryChartInstance = new Chart(ctx, {
              type: 'bar',
              plugins: [customPlugin],
              data: {
                labels: [''],
                datasets: [
                  {
                    label: 'Gasto Atual',
                    data: [spent],
                    backgroundColor: spentBarColor,
                    borderColor: spentBarBorderColor,
                    borderWidth: 2,
                    stack: 'gasto' // Empilhar com o próximo dataset
                  },
                  {
                    label: 'Novo Valor',
                    data: [amountValue],
                    backgroundColor: newValueBarColor,
                    borderColor: newValueBarBorderColor,
                    borderWidth: 2,
                    stack: 'gasto' // Empilhar com o dataset anterior
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  y: {
                    beginAtZero: true,
                    max: Math.max(newSpentTotal, budget) > 0 ? Math.max(newSpentTotal, budget) * 1.1 : 100, // Sempre mostrar pelo menos 10% acima do maior valor
                    ticks: {
                      callback: function(value) {
                        return 'R$ ' + value.toFixed(0);
                      },
                      font: {
                        size: 9
                      }
                    },
                    stacked: true // Habilitar empilhamento no eixo Y
                  },
                  x: {
                    display: false, // Ocultar eixo X pois só temos uma barra
                    stacked: true // Habilitar empilhamento no eixo X
                  }
                },
                plugins: {
                  legend: {
                    display: false
                  },
                  tooltip: {
                    enabled: false
                  }
                }
              }
            });
          }
          
          // Atualizar legenda com o nome da subcategoria
          const chartLabel = document.getElementById('subcategory_chart_label');
          if (chartLabel) {
            chartLabel.textContent = data.subcategory_name;
          }
          
          // Exibir a seção
          infoSection.style.display = 'flex';
        } else {
          infoSection.style.display = 'none';
          if (subcategoryChartInstance) {
            subcategoryChartInstance.destroy();
            subcategoryChartInstance = null;
          }
        }
      })
      .catch(error => {
        console.error('Erro ao buscar informações da subcategoria:', error);
        infoSection.style.display = 'none';
        if (subcategoryChartInstance) {
          subcategoryChartInstance.destroy();
          subcategoryChartInstance = null;
        }
      });
  }
  
  // Adicionar event listeners aos campos
  document.addEventListener('DOMContentLoaded', function() {
    const dateInput = document.getElementById('id_date');
    const amountInput = document.getElementById('id_amount');
    const subcategoryInput = document.getElementById('id_subcategory');
    const typeSelect = document.getElementById('id_type');
    
    if (dateInput) {
      dateInput.addEventListener('change', updateSubcategoryInfo);
      dateInput.addEventListener('input', updateSubcategoryInfo);
    }
    
    if (amountInput) {
      amountInput.addEventListener('input', updateSubcategoryInfo);
    }
    
    if (typeSelect) {
      typeSelect.addEventListener('change', updateSubcategoryInfo);
    }
    
    if (subcategoryInput) {
      // Monitorar mudanças no campo hidden usando setInterval (mais confiável que MutationObserver)
      let lastValue = subcategoryInput.value;
      setInterval(function() {
        if (subcategoryInput.value !== lastValue) {
          lastValue = subcategoryInput.value;
          updateSubcategoryInfo();
        }
      }, 200);
    }
    
    // Adicionar listener para mudanças no cartão selecionado
    const cardButtons = document.querySelectorAll('.card-btn');
    cardButtons.forEach(button => {
      button.addEventListener('click', function() {
        // Aguardar um pouco para garantir que o botão foi marcado como ativo
        setTimeout(updateSubcategoryInfo, 100);
      });
    });
    
    // Verificar se já há valores preenchidos ao carregar
    setTimeout(updateSubcategoryInfo, 300);
  });
</script>

<script>
  // Card selector behaviour: persist selection in localStorage and inject hidden input into the form
  (function(){
    const selector = document.getElementById('card_selector');
    if (!selector) return;
    const buttons = Array.from(selector.querySelectorAll('.card-btn'));
    const storageKey = 'selected_card_id';

    function setActive(button, doReload = false){
      buttons.forEach(b => b.classList.toggle('active', b === button));
      const id = button.getAttribute('data-card-id') || '';
      const cardName = button.getAttribute('data-card-name') || '';
      const ownerTag = button.getAttribute('data-owner-tag') || ''; // Obter tag do botão
      try { localStorage.setItem(storageKey, id); } catch(e) {}
      
      // Definir automaticamente o campo hidden owner_tag baseado no nav selecionado
      const ownerTagInput = document.getElementById('id_owner_tag');
      if (ownerTagInput) {
        ownerTagInput.value = ownerTag; // Preencher automaticamente com a tag do nav
      }
      
      // Mostrar/ocultar opção de compra parcelada baseado na seleção
      const installmentFieldset = document.getElementById('installment_fieldset');
      if (installmentFieldset) {
        // Se um cartão de crédito foi selecionado (id não vazio), mostrar o fieldset
        // Se "Débito" foi selecionado (id vazio), ocultar o fieldset
        if (id && id.trim() !== '') {
          installmentFieldset.style.display = 'block';
        } else {
          installmentFieldset.style.display = 'none';
          // Também desmarcar o checkbox e ocultar os campos de parcelas se estiverem visíveis
          const checkbox = document.getElementById('id_is_installment');
          if (checkbox) {
            checkbox.checked = false;
            toggleInstallmentFields();
          }
        }
      }

      // Aplicar filtro da tabela de últimos lançamentos conforme seleção do nav
      if (doReload) {
        const url = new URL(window.location.href);
        if (id && id.trim() !== '') {
          url.searchParams.set('payment_method', id);
          // Se for Bradesco, adicionar filtro de tag
          const isBradesco = cardName && cardName.toLowerCase().includes('bradesco');
          if (isBradesco && ownerTag) {
            url.searchParams.set('owner_tag', ownerTag);
          } else {
            url.searchParams.delete('owner_tag');
          }
        } else {
          url.searchParams.set('payment_method', 'debit');
          // Se for débito, remover filtro de tag
          url.searchParams.delete('owner_tag');
        }
        window.location.href = url.toString();
        return; // evita execução extra após intenção de recarregar
      }
    }

    buttons.forEach(btn => btn.addEventListener('click', function(){ setActive(btn, true); }));

    // Initialize
    // Priorizar payment_method da URL sobre localStorage
    const urlParamsInit2 = new URLSearchParams(window.location.search);
    const paymentMethodFromUrlInit2 = urlParamsInit2.get('payment_method');
    const alreadyRedirected = urlParamsInit2.get('_init') === '1'; // Parâmetro para evitar redirect em loop
    let saved = null;
    
    if (paymentMethodFromUrlInit2) {
      // Se payment_method da URL é 'debit', usar botão sem data-card-id (vazio)
      if (paymentMethodFromUrlInit2 === 'debit') {
        saved = '';
      } else {
        // Caso contrário, usar o ID do cartão da URL
        saved = paymentMethodFromUrlInit2;
      }
    } else if (!alreadyRedirected) {
      // Se não houver payment_method na URL e ainda não fizemos redirect, usar localStorage
      // Verificar se há mensagens na página - se houver, vamos preservá-las
      const messagesContainer = document.querySelector('.messages');
      const hasMessages = messagesContainer && messagesContainer.children.length > 0;
      
      try { 
        saved = localStorage.getItem(storageKey);
        if (saved !== null) {
          // Se houver mensagens, salvar no sessionStorage antes do redirect
          if (hasMessages) {
            try {
              const messagesText = Array.from(messagesContainer.children).map(li => ({
                text: li.textContent.trim(),
                tags: li.className
              }));
              sessionStorage.setItem('preserved_messages', JSON.stringify(messagesText));
            } catch(e) {
              console.warn('Could not preserve messages:', e);
            }
          }
          
          // Sempre fazer redirect para adicionar payment_method na URL
          // Isso garante que a coluna Tag apareça corretamente
          const url = new URL(window.location.href);
          if (saved && saved.trim() !== '') {
            url.searchParams.set('payment_method', saved);
          } else {
            url.searchParams.set('payment_method', 'debit');
          }
          // Adicionar parâmetro para evitar redirect em loop
          url.searchParams.set('_init', '1');
          // Preservar outros parâmetros da URL (como owner_tag, next_month, etc)
          window.location.href = url.toString();
          return; // Sair aqui, a página vai recarregar
        }
      } catch(e) { 
        saved = null; 
      }
    }
    
    // Restaurar mensagens preservadas do sessionStorage se existirem
    try {
      const preservedMessages = sessionStorage.getItem('preserved_messages');
      if (preservedMessages) {
        const messages = JSON.parse(preservedMessages);
        if (messages.length > 0) {
          // Aguardar um pouco para garantir que o DOM esteja pronto
          setTimeout(function() {
            let messagesContainer = document.querySelector('.messages');
            // Se não existir o container, criar um
            if (!messagesContainer) {
              const container = document.querySelector('.container');
              if (container) {
                messagesContainer = document.createElement('ul');
                messagesContainer.className = 'messages';
                container.insertBefore(messagesContainer, container.firstChild);
              }
            }
            // Adicionar as mensagens preservadas
            if (messagesContainer) {
              messagesContainer.innerHTML = messages.map(msg => 
                `<li class="${msg.tags}">${msg.text}</li>`
              ).join('');
            }
            // Limpar após exibir
            sessionStorage.removeItem('preserved_messages');
          }, 100);
        }
      }
    } catch(e) {
      console.warn('Could not restore messages:', e);
      try {
        sessionStorage.removeItem('preserved_messages');
      } catch(e2) {}
    }
    
    // Inicializar botão ativo considerando payment_method e owner_tag da URL
    const urlParamsInit = new URLSearchParams(window.location.search);
    const paymentMethodFromUrlInit = urlParamsInit.get('payment_method');
    const ownerTagFromUrl = urlParamsInit.get('owner_tag');
    
    let initial = null;
    if (paymentMethodFromUrlInit) {
      if (paymentMethodFromUrlInit === 'debit') {
        initial = buttons.find(b => {
          const btnId = b.getAttribute('data-card-id') || '';
          return btnId === '';
        });
      } else {
        // Se for Bradesco e houver tag na URL, encontrar o botão correto
        if (ownerTagFromUrl && (ownerTagFromUrl === 'Thi' || ownerTagFromUrl === 'Tha')) {
          initial = buttons.find(b => {
            const btnId = b.getAttribute('data-card-id') || '';
            const btnTag = b.getAttribute('data-owner-tag') || '';
            return btnId === paymentMethodFromUrlInit && btnTag === ownerTagFromUrl;
          });
        }
        // Se não encontrou pelo tag, procurar apenas pelo ID do cartão
        if (!initial) {
          initial = buttons.find(b => {
            const btnId = b.getAttribute('data-card-id') || '';
            return btnId === paymentMethodFromUrlInit;
          });
        }
      }
    }
    
    // Se não encontrou pela URL, usar localStorage ou primeiro botão
    if (!initial) {
      initial = buttons.find(b => {
        const btnId = b.getAttribute('data-card-id') || '';
        return btnId === (saved || '');
      }) || buttons[0];
    }
    
    setActive(initial, false); // false para não recarregar na inicialização

    // On submit, ensure a hidden input named 'credit_card' is present with the selected id (or empty for debit)
    // E tornar o campo owner_tag obrigatório apenas no submit se for Bradesco
    const form = document.querySelector('.transactions-layout .left-column form');
    if (form){
      form.addEventListener('submit', function(e){
        let hidden = form.querySelector('input[name="credit_card"]');
        if (!hidden){
          hidden = document.createElement('input');
          hidden.type = 'hidden';
          hidden.name = 'credit_card';
          form.appendChild(hidden);
        }
        const active = selector.querySelector('.card-btn.active');
        if (active) {
          const cardId = active.getAttribute('data-card-id') || '';
          hidden.value = cardId;
          // O owner_tag já está sendo preenchido automaticamente pelo setActive
          // Não precisa tornar obrigatório, pois já está sendo definido pelo nav
        }
      });
    }
  })();
</script>

<!-- Chart.js para o gráfico de subcategoria -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

{% endblock %}
